
#PowerShellã§Dockerã‚³ãƒ³ãƒ†ãƒŠã‚’èµ·å‹•
docker run -ti -v ${PWD}:/home/fenics/shared -w /home/fenics/shared dolfinx/dolfinx:v0.7.3 bash -c "source dolfinx-complex-mode && bash"

#python3

#Gmshãƒ¡ãƒƒã‚·ãƒ¥ã®èª­ã¿è¾¼ã¿

from mpi4py import MPI
from dolfinx.io import gmshio
comm = MPI.COMM_WORLD
mesh, cell_tags, facet_tags = gmshio.read_from_msh("output.msh", comm, rank=0, gdim=3)

#2.ææ–™ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨é–¢æ•°ç©ºé–“ã®è¨­å®š
import numpy as np
import ufl
from dolfinx.fem import FunctionSpace, Constant
from petsc4py import PETSc
from dolfinx import fem

E = 31.3e9        # ãƒ¤ãƒ³ã‚°ç‡ (Pa)  â€” çš®è³ªéª¨ç›¸å½“
nu = 0.3        # ãƒã‚¢ã‚½ãƒ³æ¯”
rho = 2400.0    # å¯†åº¦ (kg/mÂ³)
mu = E / (2 * (1 + nu))
lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))
K_bulk = E / (3 * (1 - 2 * nu))  # ä½“ç©å¼¾æ€§ç‡
omega = 2 * np.pi * 50.0				# åŠ æŒ¯å‘¨æ³¢æ•°
c = 3512				# éŸ³é€Ÿï¼ˆéª¨å†…éƒ¨ï¼‰
Z0 = rho * c
alpha = 0.93
R_abs = np.sqrt(1 - alpha)
Z_r = (1 + R_abs) / (1 - R_abs)
Z_a = Z_r * Z0
# è¤‡ç´ ä¿‚æ•°gammaã‚’PETSc.ScalarTypeã§å®šç¾©
gamma = fem.Constant(mesh, PETSc.ScalarType(1j * omega * rho / Z_a))
V = fem.VectorFunctionSpace(mesh, ("Lagrange", 1))
u = ufl.TrialFunction(V)
v = ufl.TestFunction(V)

#3.å¢ƒç•Œæ¡ä»¶ãƒ»åŠ æŒ¯ç‚¹è¨­å®šã®ãŸã‚ã®æƒ…å ±å–å¾—
#XcXsrvèµ·å‹•

#3.1.åŠ æŒ¯é¢ï¼ˆæ–¹å½¢éª¨è…¹å´ç«¯ï¼‰
  
import pyvista as pv
import numpy as np

# ãƒ¡ãƒƒã‚·ãƒ¥èª­ã¿è¾¼ã¿ã¨è¡¨é¢æŠ½å‡ºï¼ˆä¸‰è§’å½¢ã®é¢ã ã‘ã«ã™ã‚‹ï¼‰
mesh = pv.read("output.msh")
surface = mesh.extract_surface()
picked_faces = set()

print("çŸ©å½¢é¸æŠï¼ˆthrough=Trueï¼‰ã‚’è¤‡æ•°å›è¡Œãˆã¾ã™")
print("   â†’ Shift + R â†’ ãƒ‰ãƒ©ãƒƒã‚° â†’ Qã‚­ãƒ¼ã§ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‰ã˜ã‚‹")

while True:
    plotter = pv.Plotter()

    picked_ids = []

    # é¸æŠæ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
    def callback(picked):
        if picked.n_cells == 0:
            print("âš ï¸ é¢ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return
        ids = picked["vtkOriginalCellIds"] if "vtkOriginalCellIds" in picked.array_names else np.arange(picked.n_cells)
        picked_faces.update(ids)
        picked_ids.append(True)
        print(f"âœ… ä»Šå›é¸æŠã•ã‚ŒãŸé¢æ•°: {len(ids)}ï¼ˆç´¯è¨ˆ: {len(picked_faces)}ï¼‰")

    # ãƒ¡ãƒƒã‚·ãƒ¥æç”»ã¨çŸ©å½¢é¸æŠï¼ˆthrough=Trueï¼‰
    plotter.add_mesh(surface, show_edges=True, color="lightgray")
    plotter.enable_cell_picking(
        callback=callback,
        through=True,        
        show=True,
        style="surface"
    )
    plotter.show()

    if not picked_ids:
        print("âš ï¸ é¢ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ")

    ans = input("ç¶šã‘ã¦é¸æŠã—ã¾ã™ã‹ï¼Ÿ (y/n): ")
    if ans.lower() != "y":
        break

# âœ… æŠ½å‡ºã¨ä¿å­˜å‡¦ç†
if picked_faces:
    extracted = surface.extract_cells(list(picked_faces))
    extracted.save("selected_vibration_faces.vtu")
    with open("selected_vibration_face_ids.txt", "w") as f:
        for cid in picked_faces:
            f.write(f"{cid}\n")
    print(f"âœ… æœ€çµ‚çš„ãªé¸æŠé¢æ•°: {len(picked_faces)}")
    print("ä¿å­˜ã—ã¾ã—ãŸ: selected_vibration_faces.vtu / selected_vibration_face_ids.txt")
else:
    print("âš ï¸ é¢ã¯é¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ")

#3.2.å›ºå®šç‚¹é¸æŠ

@jupyter notebook

#ä»¥ä¸‹ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’pick_point.pyã¨ã—ã¦ä¿å­˜
import pyvista as pv

# ãƒ¡ãƒƒã‚·ãƒ¥ã®èª­ã¿è¾¼ã¿
mesh = pv.read("output.vtu")

# ãƒ”ãƒƒã‚¯æ™‚ã«å‘¼ã°ã‚Œã‚‹é–¢æ•°ï¼ˆå¼•æ•°2ã¤ï¼ï¼‰
def on_pick(point, picker):
    print("ğŸ¯ Picked Point Coordinates:", point)

# ãƒ—ãƒ­ãƒƒã‚¿ãƒ¼ç”Ÿæˆ
plotter = pv.Plotter()
plotter.add_mesh(mesh, show_edges=True, color="lightgray")

# ãƒ”ãƒƒã‚¯æœ‰åŠ¹åŒ–ï¼ˆuse_picker=True ãŒæ¨å¥¨ï¼‰
plotter.enable_point_picking(callback=on_pick, use_picker=True, show_message=True)

# è¡¨ç¤º
plotter.show()

#3.3.å¸åå¢ƒç•Œé¢é¸æŠï¼ˆå´é¢å…¨ä½“ï¼‰

import pyvista as pv
import numpy as np

# ãƒ¡ãƒƒã‚·ãƒ¥èª­ã¿è¾¼ã¿ã¨è¡¨é¢æŠ½å‡ºï¼ˆä¸‰è§’å½¢ã®é¢ã ã‘ã«ã™ã‚‹ï¼‰
mesh = pv.read("output.msh")
surface = mesh.extract_surface()
picked_faces = set()

print("âœ… çŸ©å½¢é¸æŠï¼ˆthrough=Trueï¼‰ã‚’è¤‡æ•°å›è¡Œãˆã¾ã™")
print("   â†’ Shift + R â†’ ãƒ‰ãƒ©ãƒƒã‚° â†’ Qã‚­ãƒ¼ã§ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‰ã˜ã‚‹")

while True:
    plotter = pv.Plotter()

    picked_ids = []

    # é¸æŠæ™‚ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°
    def callback(picked):
        if picked.n_cells == 0:
            print("âš ï¸ é¢ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“")
            return
        ids = picked["vtkOriginalCellIds"] if "vtkOriginalCellIds" in picked.array_names else np.arange(picked.n_cells)
        picked_faces.update(ids)
        picked_ids.append(True)
        print(f"âœ… ä»Šå›é¸æŠã•ã‚ŒãŸé¢æ•°: {len(ids)}ï¼ˆç´¯è¨ˆ: {len(picked_faces)}ï¼‰")

    # ãƒ¡ãƒƒã‚·ãƒ¥æç”»ã¨çŸ©å½¢é¸æŠï¼ˆthrough=Trueï¼‰
    plotter.add_mesh(surface, show_edges=True, color="lightgray")
    plotter.enable_cell_picking(
        callback=callback,
        through=True,        # â†â˜… ã“ã“ã‚’å¤‰æ›´
        show=True,
        style="surface"
    )
    plotter.show()

    if not picked_ids:
        print("âš ï¸ é¢ãŒé¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ")

    ans = input("ç¶šã‘ã¦é¸æŠã—ã¾ã™ã‹ï¼Ÿ (y/n): ")
    if ans.lower() != "y":
        break

# âœ… æŠ½å‡ºã¨ä¿å­˜å‡¦ç†
if picked_faces:
    extracted = surface.extract_cells(list(picked_faces))
    extracted.save("absorb_face.vtu")
    with open("absorb_face_ids.txt", "w") as f:
        for cid in picked_faces:
            f.write(f"{cid}\n")
    print(f"âœ… æœ€çµ‚çš„ãªé¸æŠé¢æ•°: {len(picked_faces)}")
    print("ä¿å­˜ã—ã¾ã—ãŸ: absorb_face.vtu / absorb_face_ids.txt")
else:
    print("âš ï¸ é¢ã¯é¸æŠã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ")


#4.	å¢ƒç•Œæ¡ä»¶ã¨åŠ æŒ¯åŠ›ã®è¨­å®šï¼ˆDirichletæ¡ä»¶ï¼‹é¢åŠ æŒ¯ï¼‰
@Docker python3
ä¿å­˜ã—ãŸé¢IDãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€å¯¾å¿œã™ã‚‹ãƒ•ã‚§ã‚¤ã‚¹ï¼é ‚ç‚¹ã‚’ç‰¹å®šã—ã¦ Dirichlet æ¡ä»¶ã‚„è·é‡ã‚’è¨­å®š

#4.1.åŠ æŒ¯é¢ã¸ã®è·é‡è¨­å®š (Neumannæ¡ä»¶)
æ–¹å½¢éª¨ä¸Šã§é¸æŠã—ãŸç‚¹ã«æœ€ã‚‚è¿‘ã„ãƒ¡ãƒƒã‚·ãƒ¥é ‚ç‚¹ã‚’æ±‚ã‚ã€ãã® DOFï¼ˆä¾‹: x è»¸æ–¹å‘ï¼‰ã«å˜ä½åŠ›ã‚’æŒ¿å…¥

from dolfinx.fem import Function, FunctionSpace, form
from ufl import inner, FacetNormal, dot, Measure
from dolfinx.mesh import locate_entities, meshtags
import numpy as np

# åŠ æŒ¯é¢ã®IDï¼ˆfacetï¼‰ã‚’èª­ã¿è¾¼ã‚€
vibration_face_ids = np.loadtxt("selected_vibration_face_ids.txt", dtype=np.int32)

# åŠ æŒ¯é¢ã®facetã‚’å–å¾—ï¼ˆdim=2ï¼‰
tdim = mesh.topology.dim
fdim = tdim - 1
mesh.topology.create_connectivity(fdim, tdim)
mesh.topology.create_connectivity(fdim, 0)

vibration_facets = []
for f in range(mesh.topology.index_map(fdim).size_local):
    linked_cells = mesh.topology.connectivity(fdim, tdim).links(f)
    if any(cell in vibration_face_ids for cell in linked_cells):
        vibration_facets.append(f)
vibration_facets = np.array(vibration_facets, dtype=np.int32)

# Meshtagsã®å®šç¾©
vibration_tag_value = 77  # â† ä»»æ„ã®æœªä½¿ç”¨ã‚¿ã‚°ç•ªå·
vibration_tags = np.full(vibration_facets.shape, vibration_tag_value, dtype=np.int32)
vibration_meshtags = meshtags(mesh, fdim, vibration_facets, vibration_tags)

# å¢ƒç•Œç©åˆ† ds ã®å†å®šç¾©
ds = Measure("ds", domain=mesh, subdomain_data=vibration_meshtags)

# åœ§åŠ›ã®å¤§ãã•
p0 = Constant(mesh, PETSc.ScalarType(63.2))  # åœ°é¢æŒ¯å‹•æƒ³å®š. 130 dBç›¸å½“ã®åœ§åŠ›

# å¤–å‘ãæ³•ç·šãƒ™ã‚¯ãƒˆãƒ«
n = FacetNormal(mesh)

# åŠ æŒ¯é¢ã‹ã‚‰ã®Neumanné …ï¼ˆå³è¾ºï¼‰
g = -p0 * n
L_neumann = inner(g, v) * ds(vibration_tag_value)


#4.2. å›ºå®šå¢ƒç•Œæ¡ä»¶ï¼ˆDirichletï¼‰
from dolfinx.mesh import locate_entities
from dolfinx.fem import locate_dofs_topological, dirichletbc, Function
import numpy as np

# å›ºå®šç‚¹ã®åº§æ¨™ï¼ˆå‰è€³éª¨å†…ç«¯ï¼‰
X0, Y0, Z0 = 387.1526816, 371.64581773, 24.99525503

# é¸æŠé–¢æ•°ï¼ˆatol=è¨±å®¹èª¤å·®ï¼‰
def point_selector(x):
    return (
        np.isclose(x[0], X0, atol=1e-3) &
        np.isclose(x[1], Y0, atol=1e-3) &
        np.isclose(x[2], Z0, atol=1e-3)
    )

# å¯¾è±¡ç‚¹ã‚’å–å¾—
fixed_points = locate_entities(mesh, 0, point_selector)

# DOFã‚’å–å¾—
dofs = locate_dofs_topological(V, 0, fixed_points)

# Dirichletå¢ƒç•Œå€¤ã‚’å®šç¾©ï¼ˆè¤‡ç´ ã‚¼ãƒ­ï¼‰
bc_value = Function(V)
bc_value.x.array[:] = 0.0 + 0.0j

# Dirichletæ¡ä»¶ã‚’æ§‹ç¯‰
bc = dirichletbc(bc_value, dofs)

#4.3.	 å¸åå¢ƒç•Œæ¡ä»¶

from dolfinx.mesh import meshtags

#å¸åå¢ƒç•Œã®é¢ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹èª­ã¿è¾¼ã¿
absorb_ids = np.loadtxt("absorb_face_ids.txt", dtype=np.int32, ndmin=1)
domain, cell_tags, facet_tags = gmshio.read_from_msh("output.msh", MPI.COMM_WORLD, 0, gdim=3)
domain.topology.create_connectivity(fdim, tdim)
domain.topology.create_connectivity(fdim, 0)
absorb_facets = []
for f in range(domain.topology.index_map(fdim).size_local):
    linked_cells = domain.topology.connectivity(fdim, tdim).links(f)
    if any(cell in absorb_ids for cell in linked_cells):
        absorb_facets.append(f)
absorb_facets = np.array(absorb_facets, dtype=np.int32)

#FacetTag ã®å®šç¾©ï¼ˆTag=99ã¨ã™ã‚‹ï¼‰
absorb_tags = np.full(absorb_facets.shape, 99, dtype=np.int32)
absorb_tag = meshtags(domain, fdim, absorb_facets, absorb_tags)

#å¢ƒç•Œç©åˆ† ds ã‚’å†å®šç¾©
ds_absorb = ufl.Measure("ds", domain=mesh, subdomain_data=absorb_tag)
a_absorb = gamma * ufl.inner(u, v) * ds_absorb(99)
